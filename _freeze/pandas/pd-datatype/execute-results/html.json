{
  "hash": "a0f7d5aa3d80ed6cb6d137b230487f23",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Data Type\"\n---\n\n\n\n\nHere is the mapping of R data types to their equivalent Python and `pandas` data types:\n\n| **R Data Type**   | **Description**                      | **Python Data Type**             | **pandas Data Type**              |\n|-------------------|--------------------------------------|----------------------------------|----------------------------------|\n| **`character`**   | String values                        | `str`                           | `object` or `string`             |\n| **`factor`**      | Categorical data with fixed levels   | `str` or `Categorical`          | `Categorical`                    |\n| **`double`**      | Decimal numbers (floating-point)     | `float`                         | `float64`                        |\n| **`integer`**     | Whole numbers                        | `int`                           | `int64`                          |\n| **`date`**        | Date values (without time)           | `datetime.date`                 | `datetime64[ns]` (with date only)|\n| **`POSIXct` / `date.time`** | Date-time values            | `datetime.datetime`             | `datetime64[ns]`                 |\n| **`logical`**     | Boolean values (TRUE/FALSE)          | `bool`                          | `bool`                           |\n| **`NA` / `NULL`** | Missing or null values               | `None`, `numpy.nan`             | `NaN`, `None`                    |\n\nBelow are detailed examples and explanations for each data type.\n\n---\n\n## Character → String (`str` or `object`)\n\n- **R**: `\"Hello\"`, `\"abc\"`\n- **Python**: `str`\n- **pandas**: By default, string columns in `pandas` are stored as `object` (a generic type that can hold anything). However, starting with **pandas 1.0**, you can explicitly use the `string` dtype.\n\n::: {#212e4a0f .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf = pd.DataFrame({'name': ['Alice', 'Bob', 'Charlie']})\nprint(df.dtypes)  # dtype will show 'object'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname    object\ndtype: object\n```\n:::\n:::\n\n\nYou can also use the newer `string` dtype:\n\n::: {#5c8c5ae0 .cell execution_count=2}\n``` {.python .cell-code}\ndf = pd.DataFrame({'name': pd.Series(['Alice', 'Bob', 'Charlie'], dtype='string')})\nprint(df.dtypes)  # dtype will show 'string'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname    string[python]\ndtype: object\n```\n:::\n:::\n\n\n---\n\n## Factor → Categorical (`Categorical`)\n\n- **R**: `factor(c(\"low\", \"medium\", \"high\"))`\n- **Python / pandas**: `pd.Categorical`\n\nIn Python, categorical data is represented using the `Categorical` data type. This is useful for values that take a limited set of distinct values (e.g., \"low\", \"medium\", \"high\").\n\n::: {#b39143df .cell execution_count=3}\n``` {.python .cell-code}\ndf = pd.DataFrame({\n    'rating': pd.Categorical(['low', 'medium', 'high', 'medium'], categories=['low', 'medium', 'high'], ordered=True)\n})\n\nprint(df)\nprint(df.dtypes)  # dtype will show 'category'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   rating\n0     low\n1  medium\n2    high\n3  medium\nrating    category\ndtype: object\n```\n:::\n:::\n\n\n---\n\n## Double → Float (`float64`)\n\n- **R**: `3.14`, `2.718`\n- **Python**: `float`\n- **pandas**: `float64`\n\nFloating-point numbers in `pandas` are represented as `float64` by default.\n\n::: {#f5a01e11 .cell execution_count=4}\n``` {.python .cell-code}\ndf = pd.DataFrame({'pi': [3.14, 2.718, 1.618]})\nprint(df.dtypes)  # dtype will show 'float64'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npi    float64\ndtype: object\n```\n:::\n:::\n\n\n---\n\n## Integer → Integer (`int64`)\n\n- **R**: `1`, `2`, `3`\n- **Python**: `int`\n- **pandas**: `int64`\n\nIn `pandas`, integer columns are represented as `int64`.\n\n::: {#13182903 .cell execution_count=5}\n``` {.python .cell-code}\ndf = pd.DataFrame({'count': [1, 2, 3, 4]})\nprint(df.dtypes)  # dtype will show 'int64'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncount    int64\ndtype: object\n```\n:::\n:::\n\n\n---\n\n## Date → `datetime.date` / `datetime64[ns]`\n\n- **R**: `as.Date(\"2021-01-01\")`\n- **Python**: `datetime.date`\n- **pandas**: `datetime64[ns]` (can store both date and time, but you can ignore the time part if you only need dates).\n\n::: {#b64577c9 .cell execution_count=6}\n``` {.python .cell-code}\ndf = pd.DataFrame({'date': pd.to_datetime(['2021-01-01', '2021-02-01', '2021-03-01'])})\nprint(df)\nprint(df.dtypes)  # dtype will show 'datetime64[ns]'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        date\n0 2021-01-01\n1 2021-02-01\n2 2021-03-01\ndate    datetime64[ns]\ndtype: object\n```\n:::\n:::\n\n\nIf you need to store just the **date** part without the time, you can format it accordingly:\n\n::: {#22b98d1c .cell execution_count=7}\n``` {.python .cell-code}\ndf['date_only'] = df['date'].dt.date\nprint(df['date_only'].head())  # dtype remains 'datetime64[ns]', but only the date part is used.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0    2021-01-01\n1    2021-02-01\n2    2021-03-01\nName: date_only, dtype: object\n```\n:::\n:::\n\n\n---\n\n## POSIXct / Date-Time → `datetime.datetime` / `datetime64[ns]`\n\n- **R**: `as.POSIXct(\"2021-01-01 12:34:56\")`\n- **Python**: `datetime.datetime`\n- **pandas**: `datetime64[ns]`\n\nFor datetime values, `pandas` uses the `datetime64[ns]` dtype, which can store both date and time.\n\n::: {#e40ae8a8 .cell execution_count=8}\n``` {.python .cell-code}\ndf = pd.DataFrame({'timestamp': pd.to_datetime(['2021-01-01 12:34:56', '2021-02-01 14:30:00'])})\nprint(df)\nprint(df.dtypes)  # dtype will show 'datetime64[ns]'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            timestamp\n0 2021-01-01 12:34:56\n1 2021-02-01 14:30:00\ntimestamp    datetime64[ns]\ndtype: object\n```\n:::\n:::\n\n\n---\n\n## Logical → Boolean (`bool`)\n\n- **R**: `TRUE`, `FALSE`\n- **Python**: `bool`\n- **pandas**: `bool`\n\nIn `pandas`, boolean values are represented with the `bool` dtype.\n\n::: {#706701a8 .cell execution_count=9}\n``` {.python .cell-code}\ndf = pd.DataFrame({'is_active': [True, False, True]})\nprint(df.dtypes)  # dtype will show 'bool'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nis_active    bool\ndtype: object\n```\n:::\n:::\n\n\n---\n\n## 8. **NA / NULL → `None` or `numpy.nan`**\n\n- **R**: `NA`, `NULL`\n- **Python**: `None` or `numpy.nan`\n- **pandas**: `NaN` or `None`\n\nIn `pandas`, missing values are typically represented by `numpy.nan` for numeric data and `None` for object or string data.\n\n::: {#b5fb09aa .cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\n\ndf = pd.DataFrame({'numbers': [1, np.nan, 3], 'names': ['Alice', None, 'Charlie']})\nprint(df)\nprint(df.dtypes)  # 'numbers' is 'float64', 'names' is 'object'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   numbers    names\n0      1.0    Alice\n1      NaN     None\n2      3.0  Charlie\nnumbers    float64\nnames       object\ndtype: object\n```\n:::\n:::\n\n\n",
    "supporting": [
      "pd-datatype_files"
    ],
    "filters": [],
    "includes": {}
  }
}